# RHS333 notes

# Important Topics for the Exam  
- DNS + DNSSEC  
- Kerberos  
- SSH  
- NFS  
- OpenSSL  
- Sendmail  
- Postfix  
- HTTPS  

# Lecture 2  

## Iptables (Lab 2.1)   
### Create a new custom chain  
```bash
# iptables -N <chain_name>  
```  
  
### Make sure all incoming traffic is processed by <chain_name> before it is processed by RH-Firewall-1-INPUT  
```bash
# iptables -I INPUT 1 -j <chain_name>  
```  
  
### Save your work  
```bash
# service iptables save
```  
  
### Create a new custom chain editing ```/etc/sysconfig/iptables``` directly  
```bash
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [1960:4012004]
:RH-Firewall-1-INPUT - [0:0]
:RHS333 - [0:0]
-A INPUT -j RHS333
-A INPUT -j RH-Firewall-1-INPUT
-A FORWARD -j RH-Firewall-1-INPUT
<reglas a completar despues>
```  
  
### Current observations  
- RH-Firewall-1-INPUT is 'lost', _no clue_ where the fuck it goes, but it disappears from ```iptables -L -v -n``` and ```/etc/sysconfig/iptables```.  
- Above might be due to incorrect or inconsistent /etc/sysconfig/iptables
  configuration.  

  

## TCP Wrappers (Lab 2.2)  
### Make sure that telnet-server and xinetd are installed _and_ enabled  
(The package ```telnet-server``` should pull both ```telnet-server``` and ```xinetd```)  
```bash
# yum install telnet-server
# chkconfig xinetd on
# chkconfig telnet on
# service xinetd start
```  

### Open up port ```23/tcp``` so that anyone on the network can connect to it  
```bash
# iptables -A RHS333 -p tcp --dport 23 -j ACCEPT
```  
Verify that the setting is correct via ```iptables -vnL```.  

### Create the ```/var/mesg/``` directory and the executable file ```/var/mesg/deny```  
```bash
# mkdir -p /var/mesg
# touch /var/mesg/deny
```  

Edit the ```/var/mesg/deny``` as follows:  
```bash
#!/bin/bash
echo "External connection refused at $(/bin/date)"
```  

### Modify the ```/etc/hosts.deny``` file so that the ```/var/mesg/deny``` script is run instead of ```in.telnetd``` for all telnet connections from outside the local network  
```bash
# echo "in.telnetd : ALL : twist /var/mesg/deny" >> /etc/hosts.deny
```  

### Modify the ```/etc/hosts.allow``` file to allow telnet connections from the example.com network (192.168.0/24) and the localhost network (127/8)  
```bash
# echo "in.telnetd : 192.168.0. 127." >> /etc/hosts.allow
```  

### Current observations  
None so far  

## xinetd SENSOR traps (Lab 2.3) 
### Verify that telnet is enabled and working  
```bash
# telnet <server>
```  

### Open the ```rlogin``` port ```(513/tcp)```  
```bash
# iptables -A RHS333 -p tcp --dport 513 -j ACCEPT
```  

### Install the ```rsh-server``` package  
```bash
# yum install rsh-server
```  
  
Edit the /etc/xinetd.d/rlogin file to include the following:
```text
service login
{
	flags		= SENSOR
	deny_time	= 2
	socket_type	= stream
	wait		= no
	user		= root
	server		= /bin/false
}
```  

And reload the ```xinetd``` service.  
```bash
# service xinetd restart
```  

### Observations  
- How can an attacker use a sensor trap against you ?  
Denial of Service Attack.  

## Understanding file context (Lab 2.4)  
- Moving keeps SELinux file contexts untouched  
- Copying replaces the SELinux file contexts with the ones corresponding to the
  user making the copy  
   
To restore the contexts of a file or directory, use ```restorecon```:  
```bash
# restorecon -FRvv /path/to/file
```  

# Lecture 3  
## Generating an RSA Private Key  
- Makefile in /etc/pki/tls/certs  
- Uses ```openssl genrsa``` command  

Usage:  
```bash
# cd /etc/pki/tls/certs
# make <sarasa>.key
```  

The enrypted key can also be generated manually by executing:  
```bash
# (umask 77; openssl genrsa 1024 > <sarasa>.key)
```  
(The ```umask 77``` is to ensure that ```<sarasa>.key``` is only readable by
root).  

## Generating a Certificate Signing Request (CSR)  
- Does not contain the private key!  
- CA must verify the identity of the CSR owner before signing  
- ```make *.csr``` creates key if necessary  
- ```openssl req``` command  

Preparing the CSR (From within ```/etc/pki/tls/certs/```:  
```bash
# (umask 77; openssl req -new -key <sarasa>.key -out <sarasa>.csr)
```  

Do not send the private key to the CA. All the CA needs is the certificate request.  

Output the contents of a CSR in a human readable format:  
```bash
# openssl req -noout -in <sarasa>.csr -text
```  

## Creating a CA-signed Certificate  
```bash
# openssl ca -in my.csr -out my.crt
```  

- Verify information, the approve.  
- Every certificate issued should have a unique serial number (stored in index.txt)  
- Keep a copy of the final CRT file so the certificate can be revoked if necessary  

## Managing a CRL  
To revoke a certificate run:  
```bash
# openssl ca -revoke <sarasa>.crt
```  

and to generate a new CRL run the command:  
```bash
# openssl ca -gencrl -out revoked.crl
```  

Some clients expect the CRL to be in DER. To convert the CRL, run:  
```bash
# openssl crl -in revoked.crl -outform DER -out revoked.der.crl
```  

To examine the contents of a CRL:  
```bash
# openssl crl -in revoked.crl -noout -text
```  

## GnuPG  
- GnuPG is a powerful encryption tool  
- To generate a key:  
```bash
# gpg --gen-key
```  
- Exchange public keys with others to encrypt email and verify signatures  

Exporting your public key to a file:  
```bash
# gpg -a -o me@example.com.pubkey --export
```  

Imports key from a file:  
```bash
# gpg --import joe@example.org.pubkey
```  

Encrypts and signs a file for Joe:  
```bash
# gpg -a -r joe@example.org --sign --encrypt filename
```  

Decrypts and verifies the signature on a file:  
```bash
# gpg --decrypt filename
```  

## Setting up a private Certificate Authority (Lab 3.1)  
### Set up /etc/pki/CA as the working directory for your CA:  
Edit ```/etc/pki/tls/openssl.cnf``` and modify the following:  
```text
dir = /etc/pki/CA
certificate = $dir/my-ca.crt
crl = $dir/my-ca.crl
private_key = $dir/private/my-ca.key
```  

### Create supporting directories:  
```bash
# mkdir -p /etc/pki/CA/{certs,crl,newcerts,private}
```  

### ```/etc/pki/CA``` should be owned by ```root:root``` and have ```0700``` permissions:  
```bash
# chown -R root:root /etc/pki/CA
# chmod -R 0700 /etc/pki/CA
```  

### Create an empty certificate index and a serial file to indicate next certificate number to be issued:  
```bash
# touch /etc/pki/CA/index.txt
# echo 01 > /etc/pki/CA/serial
```  

### In ```/etc/pki/CA``` generate a private key and a self-signed CA certificate  
```bash
# cd /etc/pki/CA
# (umask 77; openssl genrsa -out private/my-ca.key -des3 2048)
# openssl req -new -x509 -key private/my-ca.key -days 365 > my-ca.crt
```  

### Install ```httpd``` and ```mod_ssl``` and make the certificates available over the network  
```bash
# yum install -y httpd mod_ssl
# mkdir /var/www/html/certs
# cp /etc/pki/CA/my-ca.crt /var/www/html/certs
# restorecon -FRvv /var/www/
# service httpd restart
```  

### Observations  
```my-ca.crt``` in ```/var/www/html/certs``` must have SELinux context ```httpd_sys_content_t```.  



