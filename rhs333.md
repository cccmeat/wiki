# RHS333 notes

# Important Topics for the Exam  
- DNS + DNSSEC  
- Kerberos  
- SSH  
- NFS  
- OpenSSL  
- Sendmail  
- Postfix  
- HTTPS  

# Lecture 2  

## Lab 2.1: Iptables  
### Create a new custom chain  
```bash
# iptables -N <chain_name>  
```  
  
### Make sure all incoming traffic is processed by <chain_name> before it is processed by RH-Firewall-1-INPUT  
```bash
# iptables -I INPUT 1 -j <chain_name>  
```  
  
### Save your work  
```bash
# service iptables save
```  
  
### Create a new custom chain editing ```/etc/sysconfig/iptables``` directly  
```bash
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [1960:4012004]
:RH-Firewall-1-INPUT - [0:0]
:RHS333 - [0:0]
-A INPUT -j RHS333
-A INPUT -j RH-Firewall-1-INPUT
-A FORWARD -j RH-Firewall-1-INPUT
<reglas a completar despues>
```  
  
### Current observations  
- RH-Firewall-1-INPUT is 'lost', _no clue_ where the fuck it goes, but it disappears from ```iptables -L -v -n``` and ```/etc/sysconfig/iptables```.  
- Above might be due to incorrect or inconsistent /etc/sysconfig/iptables
  configuration.  

  

## Lab 2.2: TCP Wrappers  
### Make sure that telnet-server and xinetd are installed _and_ enabled  
(The package ```telnet-server``` should pull both ```telnet-server``` and ```xinetd```)  
```bash
# yum install telnet-server
# chkconfig xinetd on
# chkconfig telnet on
# service xinetd start
```  

### Open up port ```23/tcp``` so that anyone on the network can connect to it  
```bash
# iptables -A RHS333 -p tcp --dport 23 -j ACCEPT
```  
Verify that the setting is correct via ```iptables -vnL```.  

### Create the ```/var/mesg/``` directory and the executable file ```/var/mesg/deny```  
```bash
# mkdir -p /var/mesg
# touch /var/mesg/deny
```  

Edit the ```/var/mesg/deny``` as follows:  
```bash
#!/bin/bash
echo "External connection refused at $(/bin/date)"
```  

### Modify the ```/etc/hosts.deny``` file so that the ```/var/mesg/deny``` script is run instead of ```in.telnetd``` for all telnet connections from outside the local network  
```bash
# echo "in.telnetd : ALL : twist /var/mesg/deny" >> /etc/hosts.deny
```  

### Modify the ```/etc/hosts.allow``` file to allow telnet connections from the example.com network (192.168.0/24) and the localhost network (127/8)  
```bash
# echo "in.telnetd : 192.168.0. 127." >> /etc/hosts.allow
```  

### Current observations  
None so far  

## Lab 2.3: xinetd SENSOR traps  
### Verify that telnet is enabled and working  
```bash
# telnet <server>
```  

### Open the ```rlogin``` port ```(513/tcp)```  
```bash
# iptables -A RHS333 -p tcp --dport 513 -j ACCEPT
```  

### Install the ```rsh-server``` package  
```bash
# yum install rsh-server
```  
  
Edit the /etc/xinetd.d/rlogin file to include the following:
```text
service login
{
	flags		= SENSOR
	deny_time	= 2
	socket_type	= stream
	wait		= no
	user		= root
	server		= /bin/false
}
```  

And reload the ```xinetd``` service.  
```bash
# service xinetd restart
```  

### Observations  
- How can an attacker use a sensor trap against you ?  
Denial of Service Attack.  

## Lab 2.4: Understanding file context  
- Moving keeps SELinux file contexts untouched  
- Copying replaces the SELinux file contexts with the ones corresponding to the
  user making the copy  
   
To restore the contexts of a file or directory, use ```restorecon```:  
```bash
# restorecon -FRvv /path/to/file
```  

# Lecture 3  
## Generating an RSA Private Key  
- Makefile in /etc/pki/tls/certs  
- Uses ```openssl genrsa``` command  

Usage:  
```bash
# cd /etc/pki/tls/certs
# make <sarasa>.key
```  

The enrypted key can also be generated manually by executing:  
```bash
# (umask 77; openssl genrsa 1024 > <sarasa>.key)
```  
(The ```umask 77``` is to ensure that ```<sarasa>.key``` is only readable by
root).  

## Generating a Certificate Signing Request (CSR)  
- Does not contain the private key!  
- CA must verify the identity of the CSR owner before signing  
- ```make *.csr``` creates key if necessary  
- ```openssl req``` command  

Preparing the CSR (From within ```/etc/pki/tls/certs/```:  
```bash
# (umask 77; openssl req -new -key <sarasa>.key -out <sarasa>.csr)
```  

Do not send the private key to the CA. All the CA needs is the certificate request.  

Output the contents of a CSR in a human readable format:  
```bash
# openssl req -noout -in <sarasa>.csr -text
```  

## Creating a CA-signed Certificate  
```bash
# openssl ca -in my.csr -out my.crt
```  

- Verify information, the approve.  
- Every certificate issued should have a unique serial number (stored in index.txt)  
- Keep a copy of the final CRT file so the certificate can be revoked if necessary  

## Managing a CRL  
To revoke a certificate run:  
```bash
# openssl ca -revoke <sarasa>.crt
```  

and to generate a new CRL run the command:  
```bash
# openssl ca -gencrl -out revoked.crl
```  

Some clients expect the CRL to be in DER. To convert the CRL, run:  
```bash
# openssl crl -in revoked.crl -outform DER -out revoked.der.crl
```  

To examine the contents of a CRL:  
```bash
# openssl crl -in revoked.crl -noout -text
```  

## GnuPG  
- GnuPG is a powerful encryption tool  
- To generate a key:  
```bash
# gpg --gen-key
```  
- Exchange public keys with others to encrypt email and verify signatures  

Exporting your public key to a file:  
```bash
# gpg -a -o me@example.com.pubkey --export
```  

Imports key from a file:  
```bash
# gpg --import joe@example.org.pubkey
```  

Encrypts and signs a file for Joe:  
```bash
# gpg -a -r joe@example.org --sign --encrypt filename
```  

Decrypts and verifies the signature on a file:  
```bash
# gpg --decrypt filename
```  

## Lab 3.1: Setting up a private Certificate Authority  
### Set up /etc/pki/CA as the working directory for your CA:  
Edit ```/etc/pki/tls/openssl.cnf``` and modify the following:  
```text
dir = /etc/pki/CA
certificate = $dir/my-ca.crt
crl = $dir/my-ca.crl
private_key = $dir/private/my-ca.key
```  

### Create supporting directories:  
```bash
# mkdir -p /etc/pki/CA/{certs,crl,newcerts,private}
```  

### ```/etc/pki/CA``` should be owned by ```root:root``` and have ```0700``` permissions:  
```bash
# chown -R root:root /etc/pki/CA
# chmod -R 0700 /etc/pki/CA
```  

### Create an empty certificate index and a serial file to indicate next certificate number to be issued:  
```bash
# touch /etc/pki/CA/index.txt
# echo 01 > /etc/pki/CA/serial
```  

### In ```/etc/pki/CA``` generate a private key and a self-signed CA certificate  
```bash
# cd /etc/pki/CA
# (umask 77; openssl genrsa -out private/my-ca.key -des3 2048)
# openssl req -new -x509 -key private/my-ca.key -days 365 > my-ca.crt
```  

### Install ```httpd``` and ```mod_ssl``` and make the certificates available over the network  
```bash
# yum install -y httpd mod_ssl
# mkdir /var/www/html/certs
# cp /etc/pki/CA/my-ca.crt /var/www/html/certs
# restorecon -FRvv /var/www/
# service httpd restart
```  

### Observations  
```my-ca.crt``` in ```/var/www/html/certs``` must have SELinux context ```httpd_sys_content_t```.  

## Lab 3.2: Self Signed Certificates  
### Disable insecure IMAP protocol  
Edit ```/etc/dovecot.conf``` and change:  
```text
#protocols = pop pop3 imap imaps
```  
for:  
```text
protocols = imaps
```  

### Enable and start the secure IMAP service  
```bash
# chkconfig dovecot on
# service dovecot on
# iptables -A RHS333 -p tcp --dport 993 -j ACCEPT
# service iptables save
```  

### Copy ```mkcert.sh``` to ```/root/```  
```bash
# cp /usr/share/docs/dovecot<version>/examples/mkcert.sh /root/
```  

### Edit ```mkcert.sh```  
Make sure the following lines read as noted:  
```text
OPENSSL=/usr/bin/openssl
SSLDIR=/etc/pki/dovecot
OPENSSLCONFIG=/etc/pki/tls/openssl.cnf
```  

### Remove the existing certificates  
```bash
# rm -f /etc/pki/dovecot/certs/dovecot.pem
# rm -f /etc/pki/dovecot/private/dovecot.pem
```  

### Execute ```mkcert.sh``` and create the new keys  
```bash
# sh mkcert.sh
```  
Fill in the details as needed.  

### Restart ```dovecot```  
```bash
# service dovecot restart
```  

### Configure ```mutt``` on a client to use the IMAPS server  
Create a ```~/.mutt``` directory.   
Create a ```~/.muttrc``` file and set the following options:  
```text
set folder=imaps://<imaps.server.fqdn>
set spoolfile=imaps://<imaps.server.fqdn>
set imap_force_ssl=yes
```  

### Run ```mutt```  
As user ```mary``` run ```mutt```. You will be presented with an option to
(r)eject the certificate or accept it (o)nce.  
Reject it (r) and quit mutt (q).  
- Why might it be a bad idea for you to accept the certificate ?  
Someone may have forged the certificate and signed it themselves (self-signed).  

## Lab 3.3: Signing Certificates  
### Generate a new key  
```bash
# (umask 77; openssl genrsa -ds3 -out dovecot.key 2048)
```  

### Create a new CSR  
```bash
# openssl req -new -key dovecot.key -out dovecot.csr
```  
  
To see the contens of the CSR:  
```bash
# openssl req -in dovecot.csr -noout -text
```  

### As the CA, sign the request  
```bash
# openssl ca -in dovecot.csr -out dovecot.crt
```  

```/etc/pki/CA/index.txt``` will now have an entry for the certificate that has
just been generated.  
```/etc/pki/CA/serial``` will now indicate the next certificate # to be issued.  

```bash
# service dovecot restart
```  

### Run ```mutt```  
As user ```mary``` run ```mutt``` again. This time the issuer should read
"Server X Certificate Authority".  

## Lab 3.4: Installing the public CA certificate in mutt  
### Download the certificate  
```bash
# wget http://<imaps.server.fqdn>/path/to/ca-cert.crt
```  

### Configure ```mutt``` to accept the CA certificate  
Edit ```~/.muttrc``` to include the following:  
```text
set certificate_file=/path/to/ca-cert.crt
```  

### Send an email to mary so that there is something in her mail spool  
```bash
# echo WASAAAAAAAAAAAAAAAAAAAAAA | mail -s "Sup" mary
```  

### Run ```mutt``` to check for mails  
As the user ```mary``` run ```mutt```. You should not be warned about the
certificate (as the CA is now trusted) and should see the test email in the
inbox.  

## Lab 3.5: Revocation of a certificate  
### On the client, log in as ```mary``` and configure Firefox to trust your CA  
Navigate to ```http://<http.server.fqdn>/certs/path/to/ca-cert.crt``` and click on the certificate. A dialog will pop up. Check all boxes and click ```Import```.  
Alternatively, open up firefox, do ```Edit -> Preferences -> Advanced -> Encryption -> View Certificates -> Authorities -> Import -> ~/.mutt/path/to/ca-cert.crt```  

### The ```dovecot.pem``` certificate has been compromised. Look up its subject and serial number  
On the server, run:  
```bash
# openssl x509 -in /etc/pki/dovecot/certs/dovecot.pem -noout -serial -subject
```  

### Verify with ```/etc/pki/CA/index.txt```  
```bash
# cat /etc/pki/CA/index.txt
```  

### Revoke it using one of the certificates stored in ```/etc/pki/CA/newcerts/```  
```bash
# openssl ca -revoke /etc/pki/CA/newcerts/<CRT#>.pem
```  
Look again at ```/etc/pki/CA/index.txt```. The certificate should now appear as revoked.  

### Create a file to indicate the next certificate revoke list number  
```bash
# echo 00 > /etc/pki/CA/crlnumber
```  

### Build and up-to-date certificate revocation list and put the crl in the correct location  
```bash
# cd /etc/pki/CA/crl
# openssl ca -gencrl -out <ca-cert>.crl
```  
To check the contents of the CRL:  
```bash
# openssl crl -in <ca-cert>.crl -noout -text
```  

### Firefox expects CRLs to be in DER format  
```bash
# openssl crl -in <ca-cert>.crl -outform DER -out <ca-cert-DER>.crl
```  

### Load the CRL into Firefox and enable Automatic Updates  
```bash
# cp /etc/pki/CA/crl/<ca-cert-DER>.crl /var/www/html/certs/
# restorecon -FRvv /var/www/html
```  
Point Firefox to ```http://<http.server.fqdn>/certs/path/to/ca-cert-DER.crt``` and click on the 'link'.  
When prompted, indicate that Automatic Updates should be on.  

## Lab 3.6: Using gpg to exchange encrypted mail.  
### Create the users ```alice``` and ```bob``` on the client.  
```bash
# useradd alice
# useradd bob
# passwd alice
# passwd bob
```  
Note: Passwords for both users is ```redhat```.  

### Generate a public / private keypair for each user. 
```bash
# su - alice
$ gpg --gen-key
$ exit
# su - bob
$ gpg --gen-key
$ exit
```  

### Examine the public and private keys for ```alice```  
```bash
# su - alice
$ ls -l ~/.gnupg/
$ gpg --list-keys
$ gpg --list-secret-keys
```  

### Have ```bob``` export his public key into an ASCII file  
```bash
# su - bob
$ gpg --export --armor Robert > /tmp/bob.key
$ cat /tmp/bob.key
```  

### Have ```alice``` import the public key for ```bob``` into her public key ring  
```bash
# su - alice
$ gpg --import /tmp/bob.key
$ gpg --list-keys
```  

### Use ```gpg``` to have ```alice``` send ```bob``` an encrypted copy of ```/var/log/dmesg```  
```bash
# su - alice
$ cp /var/log/dmesg ./message.txt
$ gpg --encrypt --armor --recipient Robert message.txt
$ mail -s "Here's that thing" bob < message.txt.asc
```  

### Have ```bob``` save the message to a file using ```mail```  
```bash
# su - bob
$ mail
& w message_from_alice
& quit
```  

### Decrypt the message to view it  
```bash
$ less message_from_alice
$ gpg message_from_alice
```  
Note that ```gpg``` automatically performs the expected behaviour (decrypting the message).   

## Lab 3.7: Exercises  
### Using ```gpg``` have ```alice``` send ```bob``` a message encrypted with a symmetric encryption scheme  
```bash
# su - alice
$ cp /var/log/dmesg ./message.txt
$ gpg -c message.txt
```  

### Have ```alice``` both sign and encrypt a message to ```bob```. What additional piece of information will ```bob``` need before he is able to verify the signature ?  
Bob will need the public key for Alice.  
```bash
# su - alice
$ gpg --export --armor Alice > /tmp/alice.key
$ exit
# su - bob
$ gpg --import /tmp/alice.key
$ exit
# su - alice
$ cp /var/log/dmesg ./message.txt
$ gpg -sea ./message.txt
$ mail -s "A signed one" bob < message.txt.asc
$ exit
# su - bob
$ mail
& w signed_one
& q
$ gpg signed_one
```  

### Have ```alice``` create a detached signature for her message, and send ```bob``` both parts. Have ```bob``` verify the detached signature  
```bash
# su - alice
$ gpg --detach-sign
```  

### Have ```bob``` sign the public key for ```alice```, helping her convince other people that she is the appropiate owner for the public key  
```bash
# su - bob
$ gpg --sign-key Alice
```  


